/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.7-dev */

#ifndef PB_CARDBOARD_DEVICE_PB_H_INCLUDED
#define PB_CARDBOARD_DEVICE_PB_H_INCLUDED
#include <pb.h>

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Enum definitions */
typedef enum _DeviceParams_VerticalAlignmentType {
    DeviceParams_VerticalAlignmentType_BOTTOM = 0, /* phone rests against a fixed bottom tray */
    DeviceParams_VerticalAlignmentType_CENTER = 1, /* phone screen assumed to be centered w.r.t. lenses */
    DeviceParams_VerticalAlignmentType_TOP = 2 /* phone rests against a fixed top tray */
} DeviceParams_VerticalAlignmentType;

typedef enum _DeviceParams_ButtonType {
    /* No physical button, and touch screen is not easily accessible. */
    DeviceParams_ButtonType_NONE = 0,
    /* HMD has integrated magnet switch similar to original Cardboard. */
    DeviceParams_ButtonType_MAGNET = 1,
    /* At least a portion of touch screen is easily accessible to user for taps. */
    DeviceParams_ButtonType_TOUCH = 2,
    /* Touch screen is triggered indirectly via integrated button on the HMD. */
    DeviceParams_ButtonType_INDIRECT_TOUCH = 3
} DeviceParams_ButtonType;

/* Struct definitions */
typedef struct _DeviceParams {
    /* String identifying the device's vendor (e.g. "Google, Inc.").
 A device's [vendor, model] pair is expected to be globally unique. */
    bool has_vendor;
    char vendor[128];
    /* String identifying the device's model, including revision info if
 needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
 expected to be globally unique. */
    bool has_model;
    char model[128];
    /* Distance from the display screen to the optical center of lenses. */
    bool has_screen_to_lens_distance;
    float screen_to_lens_distance;
    /* Horizontal distance between optical center of the lenses. */
    bool has_inter_lens_distance;
    float inter_lens_distance;
    /* Four-element tuple (left, right, bottom, top) of left eye's view extent
 angles relative to center, assuming the following:
     * eye is aligned with optical center of lens
     * display screen is equal or larger than extents viewable through lens
     * nominal eye-to-lens distance
     * mirrored field of view will be applied to the right eye
 These values are essentially used as an optimization to avoid rendering
 pixels which can't be seen. */
    float left_eye_field_of_view_angles[4];
    /* If the phone is aligned vertically within the device by resting against
 a fixed top or bottom tray, this is the distance from the tray to
 optical center of the lenses.
 NOTE: Due to a bug in initial versions of the SDK's, this field
 must be set explicitly to .035 when vertical_alignment = CENTER. */
    bool has_tray_to_lens_distance;
    float tray_to_lens_distance;
    /* Coefficients Ki for pincushion distortion function which maps
 from position on real screen to virtual screen (i.e. texture) relative
 to optical center:

    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))

 where r is the distance in tan-angle units from the optical center,
 p the input point, and p' the output point.  Tan-angle units can be
 computed as distance on the screen divided by distance from the
 virtual eye to the screen. */
    pb_size_t distortion_coefficients_count;
    float distortion_coefficients[5]; /* Slots 8, 9 reserved for per-color channel distortion. */
    /* Optionally, whether the head mount uses a magnet in any part of its
 design.  Intended as hint as to whether phone's magnetometer is
 available for tasks such as orientation tracking. */
    bool has_has_magnet;
    bool has_magnet;
    /* Set according to vertical alignment strategy-- see enum comments above.
 NOTE: If you set this to CENTER, see special instructions for the
 tray_to_lens_distance field below. */
    bool has_vertical_alignment;
    DeviceParams_VerticalAlignmentType vertical_alignment;
    /* Specify primary input mechanism of the HMD.  Intended for advisory
 purposes only, to address simple questions such as "can HMD
 be used with apps requiring a physical button event?" or "what icon
 should be used to represent button action to the user?". */
    bool has_primary_button;
    DeviceParams_ButtonType primary_button;
} DeviceParams;


/* Helper constants for enums */
#define _DeviceParams_VerticalAlignmentType_MIN DeviceParams_VerticalAlignmentType_BOTTOM
#define _DeviceParams_VerticalAlignmentType_MAX DeviceParams_VerticalAlignmentType_TOP
#define _DeviceParams_VerticalAlignmentType_ARRAYSIZE ((DeviceParams_VerticalAlignmentType)(DeviceParams_VerticalAlignmentType_TOP+1))

#define _DeviceParams_ButtonType_MIN DeviceParams_ButtonType_NONE
#define _DeviceParams_ButtonType_MAX DeviceParams_ButtonType_INDIRECT_TOUCH
#define _DeviceParams_ButtonType_ARRAYSIZE ((DeviceParams_ButtonType)(DeviceParams_ButtonType_INDIRECT_TOUCH+1))

#define DeviceParams_vertical_alignment_ENUMTYPE DeviceParams_VerticalAlignmentType
#define DeviceParams_primary_button_ENUMTYPE DeviceParams_ButtonType


#ifdef __cplusplus
extern "C" {
#endif

/* Initializer values for message structs */
#define DeviceParams_init_default                {false, "", false, "", false, 0, false, 0, {0, 0, 0, 0}, false, 0, 0, {0, 0, 0, 0, 0}, false, 0, false, DeviceParams_VerticalAlignmentType_BOTTOM, false, DeviceParams_ButtonType_MAGNET}
#define DeviceParams_init_zero                   {false, "", false, "", false, 0, false, 0, {0, 0, 0, 0}, false, 0, 0, {0, 0, 0, 0, 0}, false, 0, false, _DeviceParams_VerticalAlignmentType_MIN, false, _DeviceParams_ButtonType_MIN}

/* Field tags (for use in manual encoding/decoding) */
#define DeviceParams_vendor_tag                  1
#define DeviceParams_model_tag                   2
#define DeviceParams_screen_to_lens_distance_tag 3
#define DeviceParams_inter_lens_distance_tag     4
#define DeviceParams_left_eye_field_of_view_angles_tag 5
#define DeviceParams_tray_to_lens_distance_tag   6
#define DeviceParams_distortion_coefficients_tag 7
#define DeviceParams_has_magnet_tag              10
#define DeviceParams_vertical_alignment_tag      11
#define DeviceParams_primary_button_tag          12

/* Struct field encoding specification for nanopb */
#define DeviceParams_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, STRING,   vendor,            1) \
X(a, STATIC,   OPTIONAL, STRING,   model,             2) \
X(a, STATIC,   OPTIONAL, FLOAT,    screen_to_lens_distance,   3) \
X(a, STATIC,   OPTIONAL, FLOAT,    inter_lens_distance,   4) \
X(a, STATIC,   FIXARRAY, FLOAT,    left_eye_field_of_view_angles,   5) \
X(a, STATIC,   OPTIONAL, FLOAT,    tray_to_lens_distance,   6) \
X(a, STATIC,   REPEATED, FLOAT,    distortion_coefficients,   7) \
X(a, STATIC,   OPTIONAL, BOOL,     has_magnet,       10) \
X(a, STATIC,   OPTIONAL, UENUM,    vertical_alignment,  11) \
X(a, STATIC,   OPTIONAL, UENUM,    primary_button,   12)
#define DeviceParams_CALLBACK NULL
#define DeviceParams_DEFAULT (const pb_byte_t*)"\x60\x01\x00"

extern const pb_msgdesc_t DeviceParams_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define DeviceParams_fields &DeviceParams_msg

/* Maximum encoded size of messages (where known) */
#define DeviceParams_size                        326

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
